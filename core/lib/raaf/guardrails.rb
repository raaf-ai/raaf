# frozen_string_literal: true

##
# Ruby AI Agents Factory (RAAF) - Guardrails Module
#
# This module provides comprehensive input and output validation capabilities
# for AI agent interactions. Guardrails act as safety filters that can validate,
# modify, or block content before it reaches the AI model (input guardrails)
# or after it's generated by the model (output guardrails).
#
# == Key Features
#
# * Input validation and filtering before AI processing
# * Output content filtering and modification after AI generation
# * Custom guardrail creation with block-based logic
# * Built-in guardrails for common use cases (length limits, profanity filtering)
# * Integration with both agent-level and run-level configuration
# * Comprehensive error handling with detailed metadata
#
# == Usage Examples
#
#   # Create a length-based input guardrail
#   length_guard = RAAF::Guardrails::LengthInputGuardrail.new(max_length: 1000)
#   agent.add_input_guardrail(length_guard)
#
#   # Create a custom input guardrail
#   pii_guard = RAAF::Guardrails::InputGuardrail.new(name: "PII_Detector") do |input|
#     if input =~ /\b\d{3}-\d{2}-\d{4}\b/  # SSN pattern
#       "Input contains sensitive PII data"
#     else
#       nil  # Allow input
#     end
#   end
#
#   # Create an output filtering guardrail
#   profanity_filter = RAAF::Guardrails::ProfanityOutputGuardrail.new
#   agent.add_output_guardrail(profanity_filter)
#
# == Architecture
#
# Guardrails follow a consistent execution pattern:
# 1. Input/Output is passed to the guardrail's `run` method
# 2. The guardrail returns a GuardrailResult indicating success/failure
# 3. If triggered, an exception is raised with detailed context
# 4. If filtering is applied, the modified content is used
#
# @author Ruby AI Agents Factory Team
# @since 0.1.0
module RAAF

  module Guardrails

    ##
    # Base error class for all guardrail-related exceptions
    #
    # This serves as the parent class for all guardrail violations,
    # allowing users to catch any guardrail-related error with a single rescue.
    #
    # @example Catch any guardrail error
    #   begin
    #     runner.run("Some input")
    #   rescue RAAF::Guardrails::GuardrailError => e
    #     puts "Guardrail violation: #{e.message}"
    #   end
    class GuardrailError < RAAF::Error; end

    ##
    # Exception raised when an input guardrail blocks user input
    #
    # This exception is thrown when an input guardrail determines that
    # user input should not be processed by the AI model. It includes
    # detailed information about what triggered the guardrail and the
    # original content that was blocked.
    #
    # @!attribute [r] triggered_by
    #   @return [String] Name of the guardrail that was triggered
    # @!attribute [r] content
    #   @return [String] The original input content that was blocked
    # @!attribute [r] metadata
    #   @return [Hash] Additional metadata about why the guardrail was triggered
    #
    # @example Handle input guardrail violations
    #   begin
    #     runner.run("Very long input that exceeds limits...")
    #   rescue RAAF::Guardrails::InputGuardrailTripwireTriggered => e
    #     puts "Input blocked by #{e.triggered_by}: #{e.metadata[:blocked_reason]}"
    #   end
    class InputGuardrailTripwireTriggered < GuardrailError

      attr_reader :triggered_by, :content, :metadata

      ##
      # Initialize an input guardrail exception
      #
      # @param message [String] Human-readable error message
      # @param triggered_by [String, nil] Name of the guardrail that triggered
      # @param content [String, nil] The original input content that was blocked
      # @param metadata [Hash, nil] Additional context about the violation
      def initialize(message, triggered_by: nil, content: nil, metadata: nil)
        super(message)
        @triggered_by = triggered_by
        @content = content
        @metadata = metadata
      end

    end

    ##
    # Exception raised when an output guardrail blocks or modifies AI output
    #
    # This exception is thrown when an output guardrail determines that
    # AI-generated content should not be returned to the user. Unlike input
    # guardrails which typically block content entirely, output guardrails
    # may also modify content before raising this exception.
    #
    # @!attribute [r] triggered_by
    #   @return [String] Name of the guardrail that was triggered
    # @!attribute [r] content
    #   @return [String] The original output content that was blocked/modified
    # @!attribute [r] metadata
    #   @return [Hash] Additional metadata including filtered content if applicable
    #
    # @example Handle output guardrail violations
    #   begin
    #     result = runner.run("Generate some content")
    #   rescue RAAF::Guardrails::OutputGuardrailTripwireTriggered => e
    #     puts "Output filtered by #{e.triggered_by}"
    #     puts "Original: #{e.metadata[:original_output]}"
    #     puts "Filtered: #{e.metadata[:filtered_output]}"
    #   end
    class OutputGuardrailTripwireTriggered < GuardrailError

      attr_reader :triggered_by, :content, :metadata

      ##
      # Initialize an output guardrail exception
      #
      # @param message [String] Human-readable error message
      # @param triggered_by [String, nil] Name of the guardrail that triggered
      # @param content [String, nil] The original output content
      # @param metadata [Hash, nil] Additional context including filtered content
      def initialize(message, triggered_by: nil, content: nil, metadata: nil)
        super(message)
        @triggered_by = triggered_by
        @content = content
        @metadata = metadata
      end

    end

    ##
    # Result object returned by guardrail execution
    #
    # This class encapsulates the result of running a guardrail against input or output content.
    # It indicates whether the guardrail was triggered (blocking/modifying content) and provides
    # detailed information about any modifications or violations detected.
    #
    # @!attribute [rw] output
    #   @return [Output] Detailed output information including metadata
    # @!attribute [rw] tripwire_triggered
    #   @return [Boolean] Whether the guardrail detected a violation
    #
    # @example Check if guardrail was triggered
    #   result = guardrail.run(context, agent, input)
    #   if result.tripwire_triggered?
    #     puts "Guardrail blocked input: #{result.output.output_info[:blocked_reason]}"
    #   end
    class GuardrailResult

      attr_accessor :output, :tripwire_triggered

      ##
      # Initialize a guardrail result
      #
      # @param output [Output, nil] Output information object
      # @param tripwire_triggered [Boolean] Whether the guardrail was triggered
      def initialize(output: nil, tripwire_triggered: false)
        @output = output || Output.new
        @tripwire_triggered = tripwire_triggered
      end

      ##
      # Check if the guardrail detected a violation
      #
      # @return [Boolean] true if the guardrail was triggered, false otherwise
      def tripwire_triggered?
        @tripwire_triggered
      end

      ##
      # Output information container for guardrail results
      #
      # This class holds detailed metadata about guardrail execution,
      # including reasons for blocking content, original/filtered content,
      # and other contextual information that may be useful for debugging
      # or user feedback.
      #
      # @!attribute [rw] output_info
      #   @return [Hash] Metadata about the guardrail execution
      #
      # @example Access guardrail metadata
      #   result = guardrail.run(context, agent, input)
      #   info = result.output.output_info
      #   puts "Blocked reason: #{info[:blocked_reason]}"
      #   puts "Original: #{info[:original_output]}"
      #   puts "Filtered: #{info[:filtered_output]}"
      class Output

        attr_accessor :output_info

        ##
        # Initialize output information container
        #
        # @param output_info [Hash, nil] Initial metadata hash
        def initialize(output_info: nil)
          @output_info = output_info || {}
        end

      end

    end

    ##
    # Base class for input guardrails
    class InputGuardrail

      attr_reader :name, :instructions, :validation_proc

      def initialize(name: nil, instructions: nil, &block)
        @name = name || self.class.name
        @instructions = instructions
        @validation_proc = block
      end

      def get_name
        @name
      end

      def run(_context_wrapper, _agent, input)
        result = GuardrailResult.new
        result.output = GuardrailResult::Output.new

        if @validation_proc
          validation_result = @validation_proc.call(input)

          if validation_result.is_a?(String)
            # String result means the input was blocked
            result.tripwire_triggered = true
            result.output.output_info = { blocked_reason: validation_result }
          elsif validation_result == false
            # False means input was blocked
            result.tripwire_triggered = true
            result.output.output_info = { blocked_reason: "Input blocked by guardrail" }
          end
          # nil or true means input is allowed
        end

        result
      end

    end

    ##
    # Base class for output guardrails
    class OutputGuardrail

      attr_reader :name, :instructions, :filter_proc

      def initialize(name: nil, instructions: nil, &block)
        @name = name || self.class.name
        @instructions = instructions
        @filter_proc = block
      end

      def get_name
        @name
      end

      def run(_context_wrapper, _agent, output)
        result = GuardrailResult.new
        result.output = GuardrailResult::Output.new

        if @filter_proc
          filtered_output = @filter_proc.call(output)

          if filtered_output != output
            # Output was modified, return the filtered version
            result.output.output_info = { original_output: output, filtered_output: filtered_output }
          end
        end

        result
      end

    end

    ##
    # Simple length-based input guardrail
    class LengthInputGuardrail < InputGuardrail

      def initialize(max_length:, name: "LengthGuardrail")
        super(name: name, instructions: "Block inputs longer than #{max_length} characters") do |input|
          "Input too long: #{input.length} characters (max: #{max_length})" if input.length > max_length
        end
      end

    end

    ##
    # Simple profanity filter output guardrail
    class ProfanityOutputGuardrail < OutputGuardrail

      PROFANITY_WORDS = %w[damn hell].freeze

      def initialize(name: "ProfanityFilter")
        super(name: name, instructions: "Filter profanity from output") do |output|
          filtered = output.dup
          PROFANITY_WORDS.each do |word|
            filtered.gsub!(/\b#{Regexp.escape(word)}\b/i, "[filtered]")
          end
          filtered
        end
      end

    end

  end

end
